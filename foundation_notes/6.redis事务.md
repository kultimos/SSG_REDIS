# redis事务的概念
  可以一次性执行多个命令,本质是一组命令的集合;一个事务中的所有命令都会序列化,按顺序地串行化执行而不会被其他命令插入,不会加塞
  
# redis事务的一些特性
  - 单独的隔离操作: redis的事务仅仅是保证事务里的操作会被连续独占的执行,redis命令执行是单线程架构,在执行完事务内所有指令前是不可能再去同时执行其他客户端的请求的
  - 没有隔离级别的概念: 因为事务提交前任何指令都不会被实际执行,也就不存在"事务内的查询要看到事务里的更新,在事务外查询不能看到"这种问题了
  - 不保证原子性: redis的事务不保证原子性,也就是不保证所有指令同时成功或同时失败,只有决定是否开始执行全部指令的能力,没有执行到一半进行回滚的能力;
  - 排它性: redis会保证一个事务内的命令依次执行,而不会被其他命令插入

# redis事务命令
  - discard        取消事务,放弃执行事务块内的所有命令
  - exec           执行所有事务块内的命令
  - multi          标记一个事务块的开始
  - unwatch        取消watch命令对所有key的监视
  - watch key      监视一个(或多个)key,如果在事务执行之前这个(或这些)key被其他命令所改动,那么事务将被打断;

# 案例演示
  - case1: 正常执行
    root> multi         //表示开启一个事务
    root> set k1 v1
    root> set k2 v2
    root> exec          //表示要依次顺序执行队列中的所有命令

  - case2: 放弃事务
    root> multi         //表示开启一个事务
    root> set k1 v1
    root> set k2 v2
    root> discard       //表示放弃执行队列中的所有命令  

  - case3: 全体连坐
    root> multi         //表示开启一个事务
    root> set k1 v1
    root> set k2        //包含语法错误的命令
    root> exec          //当队列中包含语法错误的命令,在调用exec执行事务时,无法执行,会取消全部的事务队列中全部命令

  - case4: 冤头债主
    root> multi         //表示开启一个事务
    root> set k1 v1
    root> incr email    //对email键的value值进行自增,语法检查没问题,但是我们的email作为一个字符串是无法自增的
    root> exec          //所以当执行exec时,并不会因为包含语法错误而取消队列中全部命令,而是会均正常执行,只是incr自增操作对应的那条语句
                          因为无法对字符串进行自增会抛出异常,但却并不会影响队列中其他命令
    case3和case4体现了redis事务和传统数据库事务的区别,一方面是redis不存在"要么一起成功,要么一起失败"这个概念,并且redis事务并没有回滚的能力;

  - case5: watch监控
    redis使用watch来提供乐观锁定,类似于CAS;
    redis的乐观锁也是保持乐观,每次去取数据都默认不会有人修改,但是在最终更新时会判断一下是否真的没人修改过;redis的乐观锁依赖于 watch multi exec三步走, 
  watch先对一个或多个key进行监控,multi表示开启事务,开启后的命令都会依次进入命令队列之中,但不会立即执行;而exec就是将命令队列中的命令依次执行,但是如果在
  执行完所有命令的这个过程中,有任意一个被监控的key的值发生了变化,那么整个事务队列中的所有命令都不会执行,数据的改动也不会生效,这就是redis的乐观锁;需要注意,
  即使是未被监控的key的修改加入了事务队列,也是会因为被监控的key在事务执行过程中的变化,而导致其改动失效;
  
  可以通过unwatch取消对那些key的监控,可以理解为一种手动释放乐观锁的行为;
  - watch unwatch multi exec
  一旦执行了exec,那么之前设置的watch监控就都会被取消
  当客户端连接丢失时(比如退出链接),也会取消所有的监控;

