# redis事务的概念
  可以一次性执行多个命令,本质是一组命令的集合;一个事务中的所有命令都会序列化,按顺序地串行化执行而不会被其他命令插入,不会加塞
  
# redis事务的一些特性
  - 单独的隔离操作: redis的事务仅仅是保证事务里的操作会被连续独占的执行,redis命令执行是单线程架构,在执行完事务内所有指令前是不可能再去同时执行其他客户端的请求的
  - 没有隔离级别的概念: 因为事务提交前任何指令都不会被实际执行,也就不存在"事务内的查询要看到事务里的更新,在事务外查询不能看到"这种问题了
  - 不支持原子性: redis的事务不支持原子性,因为它不保证所有指令同时成功或同时失败,只有决定是否开始执行全部指令的能力,没有执行到一半进行回滚的能力,这与我们通常的事务
    对于原子性的定义完全不符,所以在周阳老师前后讲述不一致的情况下,我个人认为redis的事务不支持原子性;
  - 排它性: redis会保证一个事务内的命令依次执行,而不会被其他命令插入
  其实相较于普通的事务,最核心的区别在于没有回滚能力,如果事务队列中包含的命令有语法错误,那么该事务队列中的所有命令都会执行失败,而如果不是语法错误,而是一些具体修改时
会出现的错误,那么就是事务队列中正确的命令正常执行,有问题的命令抛出异常;而通常的事务则是要么全部执行成功,要么全部回滚,不存在中间状态;所以我认为redis事务不支持原子性,
也不支持事务回滚,这是他相较于通常事务最大的区别;

# redis事务命令
  - discard        取消事务,放弃执行事务块内的所有命令
  - exec           执行所有事务块内的命令
  - multi          标记一个事务块的开始
  - unwatch        取消watch命令对所有key的监视
  - watch key      监视一个(或多个)key,如果在事务执行之前这个(或这些)key被其他命令所改动,那么事务将被打断;

# 案例演示
  - case1: 正常执行
    root> multi         //表示开启一个事务
    root> set k1 v1
    root> set k2 v2
    root> exec          //表示要依次顺序执行队列中的所有命令

  - case2: 放弃事务
    root> multi         //表示开启一个事务
    root> set k1 v1
    root> set k2 v2
    root> discard       //表示放弃执行队列中的所有命令  

  - case3: 全体连坐
    root> multi         //表示开启一个事务
    root> set k1 v1
    root> set k2        //包含语法错误的命令
    root> exec          //当队列中包含语法错误的命令,在调用exec执行事务时,无法执行,会取消全部的事务队列中全部命令

  - case4: 冤头债主
    root> multi         //表示开启一个事务
    root> set k1 v1
    root> incr email    //对email键的value值进行自增,语法检查没问题,但是我们的email作为一个字符串是无法自增的
    root> exec          //所以当执行exec时,并不会因为包含语法错误而取消队列中全部命令,而是会均正常执行,只是incr自增操作对应的那条语句
                          因为无法对字符串进行自增会抛出异常,但却并不会影响队列中其他命令
    case3和case4体现了redis事务和传统数据库事务的区别,一方面是redis不存在"要么一起成功,要么一起失败"这个概念,并且redis事务并没有回滚的能力;

  - case5: watch监控
    redis使用watch来提供乐观锁定,类似于CAS;
    redis的乐观锁也是保持乐观,每次去取数据都默认不会有人修改,但是在最终更新时会判断一下是否真的没人修改过;redis的乐观锁依赖于 watch multi exec三步走, 
  watch先对一个或多个key进行监控,multi表示开启事务,开启后的命令都会依次进入命令队列之中,但不会立即执行;而exec就是将命令队列中的命令依次执行,但是如果在
  执行完所有命令的这个过程中,有任意一个被监控的key的值发生了变化,那么整个事务队列中的所有命令都不会执行,数据的改动也不会生效,这就是redis的乐观锁;需要注意,
  即使是未被监控的key的修改加入了事务队列,也是会因为被监控的key在事务执行过程中的变化,而导致其改动失效;
  
  可以通过unwatch取消对那些key的监控,可以理解为一种手动释放乐观锁的行为;
  - watch unwatch multi exec
  一旦执行了exec,那么之前设置的watch监控就都会被取消
  当客户端连接丢失时(比如退出链接),也会取消所有的监控;

