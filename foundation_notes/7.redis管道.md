# redis管道
  - 解决痛点:  
      客户端向服务端发送命令有四步:(发送命令 -> 命令排队 -> 命令执行 -> 返回结果),并监听socket返回,通过以阻塞模式等待服务端响应;而服务端,
    会将命令处理后,将结果返回给客户端;上述的两步称为RTT(Round Trip Time,简称RTT,即数据包往返于两端的时间);
      那么如果同时需要执行大量的命令,那么就要等待上一条命令应答后再执行,这中间不仅仅多了RTT,而且还频繁调用系统IO,发送网络请求,同时需要redis
    多次调用read()和write()系统方法,系统方法会将数据从用户态转移到内核态,这样就会对进程上下文有比较大的影响了,性能不太好;
  - 概念: 
      管道可以一次性发送多条命令给服务端,服务端依次处理完毕后,通过一条响应一次性将结果返回,通过减少客户端与redis的通信次数来实现降低往返延时时间;
    pipeline实现的原理是队列,先进先出特性就保证了数据的顺序性;需要注意,pipeline,仅仅是将命令打包一次性发送,对整个redis的执行不造成其他任何影响;
       其实管道与redis的批处理命令mset、mget的思路是大体相同的,但是mset、mget只能处理string类型的命令,但实际工作中,可能需要跨类型的进行多个键
    的批处理操作,这就需要用到管道;下面会对管道和批处理命令进行对比

# 案例实操
  首先创建一个[cmd.txt文件,该文件包含着多条命令](7.cmd.txt)
  使用命令
  root> cat cmd.txt | redis-cli -a 1234567a --pipe 
  解释下,cat cmd.txt就是将结果显示,类似于echos,通过管道符|就可以将数据传给redis,又通过--pipe说明要使用redis的管道,从而实现多条命令的一次性执行;
  
# pipeline与原生批量命令对比
  - 原生命令mset、mget具有原子性,而pipeline并不具有原子性
  - 原生批处理命令一次只能执行一种命令(只有字符串类型的命令),pipeline支持批量执行不同类型命令
  - 原生批处理命令是redis服务端实现,而pipeline需要服务端和客户端共同完成

# pipeline与事务对比
  - 管道一次性将多条命令发送到服务器,事务则是一条一条的发,事务只有在接收到exec命令后才会执行,管道不会;
  - 执行事务时会阻塞其他命令的执行,而执行管道中的命令不会;

# 使用pipeline的注意事项
  - pipeline缓冲的指令只是会依次执行,不保证原子性,如果执行中指令发生异常,将会继续执行后续的指令
  - 使用pipeline组装的命令个数不能太多,不然数据量过大,客户端阻塞的时间可能过久,并且服务端会将响应放到一个队列中,该队列占据内存,长时间阻塞也会增加内存负担;