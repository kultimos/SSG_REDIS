# 通过命令实现主从复制(当次有效)
  - 主从复制(配从不配主) ———— 表示当前库和一个库建立主从关系,当前库为从库
    replicaof 主库ip 主库端口      
  - 改换门庭  ———— 表示当前库已经有一个主库,但要更换主库
    slaveof 新主库IP 新主库端口
  - 自立为王  ———— 表示当前库不在作为一个从库,而要作为主库
    slaveof no one

# 通过配置文件的修改实现主从复制(永久有效)
  1)准备三台虚拟机,作为本次操作的集群;
  2)进入主机的/opt/redis-7.0.0目录,执行cp redis.conf /myredis/redis6379.conf,实现拷贝一份纯净的redis配置文件,以供我们后续进行主从复制配置使用;
  3)在redis6379.conf文件中修改配置: daemonize yes
  4)注释掉 bind 127.0.0.1 -::1
  5)在redis6379.conf文件中修改配置: protected-mode no
  6)修改端口,这一步三台机器略有不同,主机依然保持6379(该配置大概在138行),两个从机分别设置为6380和6381
  7)修改当前工作目录,在redis6379.conf文件中修改配置(该配置大概在504行): dir /myredis
  8)修改日志文件存储目录,在redis6379.conf文件中修改配置(该配置大概在354行): logfile "/myredis/6379.log"
  9)设置requirepass,访问redis服务器密码,在redis6379.conf文件中修改配置： requirepass 1234567a
  10)设置rdb文件名称,在redis6379.conf文件中修改配置: dbfilename dump6379.rdb
  11)设置从机访问主机的通行密码masterauth,从机需要配置,主机不用: masterauth "1234567a"
  12)设置从机访问主机的地址和端口,从机需要配置,主机不用 : replicaof 192.168.10.132 6379
  11,12两步对应配置文件大约在528行左右;

  上述步骤执行完毕后,开启对应虚拟机上对应端口的redis服务,然后查看master的log日志,可以看到是否成功同步的信息,在成功建立主从复制的关系以后,在主机的set k v,
就可以在从机种找到对应的数据了;


# 主从问题演示
  - 从机是否可以执行写命令？
    不可以,从机只能读取,不能进行写操作;
  - 从机切入点问题,slave是从头开始复制还是从切入点开始复制;假设master启动,写入k3;slave1跟着master同时启动,跟着写到k3;slave2写到k3后才启动,那之前的数据是否也会复制？
    是可以的,即如果过程中某台slave宕机了,当再次启动后,依然可以把该机器掉线时期master新增的数据复制过来;
  - 主机shutdown后,从机会上位吗
    不会,
  - 主机shutdown后,重启后主从关系还在吗？从机还能否顺利复制？
    在的,可以顺利复制;

# redis主从复制之薪火相传
  最初我们是一个master和两个slave(slave1和slave2),这是我们常见的主从复制架构;但还有一种薪火相传架构,即master->slave1->slave2,即slave2不在认master为主节点,转为认
一个slave节点slave1作为主节点,从而形成链式结构;需要注意这种结构下,master的数据依然能够同步到slave2,但是中间的slave1虽然是slave2的master节点,但其本质上还是一个slave
节点,所以中间节点slave1也是不能执行写操作的;

# 主从复制工作流程总结(首次通过rdb进行全量同步,之后通过心跳维护通信,并实时进行增量同步,另外即使从机宕机,重启后依然可以同步到自己掉线期间主机新增的数据)
  - slave启动,同步初请 
    - slave启动成功连接到master后会发送一个sync命令
    - slave首次全新连接master,一次全量复制将被自动执行,slave自身原有数据会被master数据覆盖清除;

  - 首次连接,全量复制
    - master节点收到sync命令后会开始在后台保存快照(即RDB持久化,主从复制时会触发RDB),同时将收集所有接收到的用于修改数据集命令缓存起来,master节点执行完RDB持久化同步后,
    master将rdb快照文件和所有缓存的命令发送到所有slave,以完成一次完全同步
    - 而slave服务在接收到数据库文件数据后,将其存盘并加载到内存中,从而完成复制初始化

  - 心跳持续,保持通信
    master发送ping包的周期,默认是10s,根据配置: repl-ping-replica-period 10

  - 进入平稳,增量复制
    master继续将新的收集到的修改命令自动依次传给slave,完成增量同步

  - 从机下线,重连续传
    master会检查backlog里面的offset,master和slave都会保存一个复制的offset还有一个masterId,offset是保存在backlog中的;
    从机重启后,master会按照从机已复制的offset和master自己的offset比对,将增量数据复制给从机;

# 主从复制的缺点
  - 复制延时,信号衰减
    由于所有写操作都是现在master进行操作,然后同步更新到slave上,所以从master同步到slave机器有一定的延迟,当系统很繁忙的时候,延迟问题就更加严重,
  slave机器数量的增加也会使这个问题更加严重;
  - 因为主从复制的架构中,即使master宕机也不会有slave节点顶上,就造成了一旦master宕机,整个服务就处在只能读不能写的半瘫痪状态;也是为了解决这个痛点,
  所以引出了后续我们要学习的哨兵和集群;
