# String数据结构介绍
  String类型有三大物理编码方式
  - int: 保存long型的64位有符号整数,取值范围: -2^63 ~ 2^63 - 1,只有整数才会使用int,如果是浮点数,redis会先将其转化为字符串值,然后再保存
  - embstr: 代表emb格式的SDS简单动态字符串,保存长度小于44字节的字符串
  - raw: 保存长度大于44字节的字符串
  在redis中,包含字符串值的键值对都是由SDS实现的(Redis中所有的键都是由字符串实现的,即底层是由SDS实现的,Redis中所有的值对象中包含的字符串对象底层也是由SDS实现的)

# SDS简单动态字符串
  redis中的String数据结构底层原理是通过简单动态字符串(SDS)来实现的,简单动态字符是redis自己实现的一种字符串类型,与C语言的字符串想比,它具有更多的功能和优势
  简单动态字符串的结构如下:
  plaintextCopy codestruct sdshdr {
    int len;       //已使用的长度
    int free;      //剩余的空间
    int alloc;     //分配的空间长度,用于空间预分配
    char buf[];    //实际存储的字符数组
  }
  简单动态字符串SDS的特点如下:
  - O(1)复杂度获取字符串长度
  - 二进制安全,buf[]是一个字符数组,可以存任何二进制数据,因此可以处理任意类型的数据,而不仅仅是字符串;传统的C语言字符串(以\0结尾的字符数组)存在一个限制,
  即不能包含字符\0,因为\0会被视为字符串的结束符,这使得传统字符串无法直接处理包含\0的二进制数据或者特殊字符的数据;而SDS克服了这个限制,它可以存储任何
  二进制数据,因为SDS内部并不依赖于\0结尾来判断字符串结束;
  - 兼容部分C字符串函数: buf[]虽然不会将'\0'视为字符串结束标志,但是也确实是以'\0'结尾的,所以可以使用一些C字符串函数进行操作
  - 空间预分配,SDS修改后,len长度如果小于1M,那么将会额外分配与len相同长度的未使用空间,系统通过给你分配稍大的空间来避免频繁的扩展操作;
  如果修改后长度大于1M,那么将会分配1M的使用空间,剩余的由SDS动态低进行额外的空间分配;
  - 惰性空间释放,SDS缩短时并不会回收多余的内存空间,而是使用free将多余的空间记录下来,如果后续有变更操作,直接用free中记录的空间,加少了内存的分配;

# 源码分析————set k v 底层都会发生什么
  - 会先进行一次编码类型判断,看是int、embstr还是raw
    - 如果是int的话,我们需要知道redis在启动时会预先建立10000个分别存储0-9999的redisObject变量作为共享对象,这意味着如果set字符串的键值在0~10000之间的话,则可以直接指向redis共享池中的共享对象
    而不需要再建立新对象,这里的共享池有些类似于java中的常量池
    - 如果是小于44字节的字符串的话,则是embstr;对于embstr,redisObject对象和实际存储字符串的SDS结构体是连续分配的一块内存,所以这也是为什么embstr叫嵌入式字符串,因为像是value(embstrSDS字符串)嵌入到
    key(redisObject)中,并且这种设计也让结构更加紧凑;
    - 如果大于44字节的字符串,则是raw,raw相比于embstr除了字符串长度的另一点不同就是,在raw的编码格式中,动态字符串SDS的内存与其依赖的redisObject的内存不再连续
      此外,对于embstr,由于其实现是只读的,因此在对embstr对象进行修改时,都会先转化为raw再进行修改;因此,只要是修改embstr对象,修改后的对象一定是raw的,无论是否达到了44个字节;
    
# embstr字符串的特点
  - embstr编码的字符串是只读的
  - redis在处理比较短的字符串时,会将其内容直接存储在其redisObject对象之后,而不会通过指针引用另外的内存区域,这种方式避免了频繁的内存分配和释放操作,提高了性能和内存使用率
  - embstr主要适用于短小的字符串(redis中可能绝大多数字符串都是这种较短小的字符串),通过牺牲部分灵活性来换取内存和性能上的优势,特别是在存储大量小字符串的场景中(这种场景是大多数场景);
