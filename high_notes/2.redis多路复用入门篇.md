# 既然redis单线程也有诸多优点,那为何又选择逐渐加入了多线程特性呢？
  - 在redis3.x版本时有一个经典故障,就是大key删除的阻塞问题;正常情况下使用del指令可以很快的删除数据,但是当被删除的key是一个非常大的对象时,例如是一个包含了大量元素的hash集合时,
  那么del指令就会造成redis主线程卡顿;redis4.x中就引入了多个线程爱实现数据异步惰性删除的功能,从而避免大key删除造成的redis卡顿问题,但其处理读写请求的仍然只有一个线程,所以仍然算
  是狭义上的单线程;
  - 随着硬件的更新,技术与时俱进的迭代;引入多线程特性可以更好地利用多核处理器的性能,提高Redis在处理大规模数据和高并发请求时的性能表现;

# redis6/7的重要新特性————多线程
  随着网络硬件的性能提升,redis的性能瓶颈有时会出现在网络IO的处理上,也就是说,单个主线程处理网络请求的速度跟不上底层网络硬件的速度,为了应对这个问题,redis6/7采用多个IO线程来处理
网络请求,提高网络请求处理的并行度;
  但是,redis的多IO线程只是用来处理网络请求的,对于读写操作命令,redis仍然使用单线程来处理;这是因为redis处理请求时,网络处理经常是瓶颈,通过多个IO线程并行处理网络操作,可以提升实例
的整体处理性能;而继续使用单线程执行命令操作,就不用为了保证lua脚本、事务原子性,额外开发多线程互斥加锁机制了,这样一来,redis线程模型实现就简单了;

# 主线程和IO线程是怎么协作完成请求处理的？大致分为四阶段
  - 服务端和客户端建立socket连接,并分配处理线程
    首先,主线程负责接收建立连接请求;当有客户端请求和实例建立socket连接时,主线程会创建和客户端的连接,并把socket放入全局等待队列中;紧接着,主线程通过轮询方法把socket连接分配给
  IO线程;
  - IO线程读取并解析请求
    主线程一旦把socket分配给IO线程,就会进入阻塞状态,等待IO线程完成客户端请求读取和解析,因为有多个IO线程并行处理,所以这个过程很快就可以完成;
  - 主线程执行请求操作
    等到IO线程解析完请求,主线程还是会以单线程的方式执行这些命令操作
  - IO线程回写socket和主线程清空全局队列
    当主线程执行完请求操作后,会把需要返回的结果写入缓冲区,然后,主线程会阻塞,等待IO线程把这些结果回写到socket中,并返回给客户端;和IO线程读取和解析请求一样,IO线程回写socket时,
  也是有多个线程在并发执行,所以写回socket的速度也很快;等到IO线程回写socket完毕,主线程会清空全局队列,等待客户端的后续请求;

# Unix网络编程中的五种IO模型
  Blocking IO 阻塞IO 、 NoneBlocking IO 非阻塞IO 、 IO multiplexing IO多路复用 、 signal driven IO 信号驱动IO 、 asynchronous IO 异步IO
  与redis相关的就是IO多路复用,也是我们学习的重点;
    
#  linux中文件描述符的概念
  - 文件描述符
    文件描述符是计算机科学中的一个术语,是一个用于表述指向文件的引用的抽象化概念;文件描述符在形式上是一个非负整数;实际上,它是一个索引值,指向内核为每一个进程所维护的该进程打开文件的
  记录表;当程序打开一个现有文件或者创建一个新文件时,内核向进程返回一个文件描述符;在程序设计中,文件描述符这一概念往往只适用于unix、linux这样的操作系统;简称为:FD
    我们可以这样理解当我们试图用redis-cli -a 1234567a 去连接一个redis服务时,一旦连接成功,就会在redis服务端中写入一个对应我们当前客户端的文件描述符,如果有多个客户端同时请求
  服务端,为每次请求分配一个线程,这样就太费了;因此,我们只使用一个线程来监听多个文件描述符,这就是IO多路复用;


# 初识多路复用
  - IO
    即为网络IO,尤其指操作系统层面指数据在内核态和用户态之间的读写操作;
  - 多路
    多个客户端连接(连接就是套接字描述符,即socket或channel)
  - 复用
    复用一个或几个线程
  - IO多路复用是什么(第一种解释比较官方,第二种解释比较人性化,第三种解释比较总结,重在理解)
    - 一种同步的IO模型,实现一个线程监视多个文件句柄,一旦某个文件句柄就绪就能够通知到对应应用程序进行相应的读写操作,没有文件句柄就绪时就会阻塞应用程序,从而释放CPU资源;
    - 一个或一组线程(池化)处理多个TCP连接,使用单线程就能够实现同时处理多个客户端的连接,无需创建或者维护过多的进程/线程;
    - 一个服务端进程可以同时处理多个套接字描述符
  - 实现多路复用的模型有三种,可以分为 select -> poll -> epoll三个阶段来描述,epoll是我们的重点

# 案例理解多路复用
  模拟一台tcp服务器处理30个客户socket
  假设你是一个老师,让30个同学解答一道考题,然后负责验收学生答卷,你有下面几个选择
  - 第一种,轮询: 按顺序逐个验收,先验收A、在验收B,之后是C,D...,这中间如果有一个学生卡住,全班都会被耽误,你用循环挨个处理socket,根本不具有并发能力;
  - 第二种,一对一: 创建30个分身,每个分身线程检查一个学生的答案是否正确,这种类似于为每一个客户创建一个进程或者线程处理连接;
  - 第三种,响应式处理: 你站在讲台上等,谁解答完谁举手,这时C、D举手,表示他们解答问题完毕,你下去依次检查C、D的答案,然后继续回到讲台上等,此时E、A又举手,再去处理E、A;
  这种模式就是IO复用模型,linux下的select、poll和epoll就是干这个的;将用户socket对应的文件描述符注册进epoll,然后epoll帮你监听哪些FD对应的socket上有消息到达,
这样就避免了大量的无用操作,此时socket就应该采用非阻塞模式,这样整个过程中只在调用select、poll、epoll这些调用的时候才会阻塞,收发客户消息是不会阻塞的,整个过程或者
线程就被充分利用起来,这就是事件驱动,所谓的reactor模式;
  在单个线程中通过记录跟踪每一个socket(IO流)的状态来同时管理多个IO流,只使用一个服务端进程可以同时处理多个套接字描述符,目的是尽可能多的提高服务器的吞吐能力;

# redis为什么这么快？(这个其实侧重点还是在多路复用和IO多线程这里,完整的redis为啥这么快的面试回答还是要以interview工程里的解答为主)
  IO多路复用+epoll函数使用,才是redis为什么这么快的原因,而不是仅仅单线程+内存操作的原因;在早期redis单主线程的模式时,仅通过多路复用就满足了单工作线程应付多个连接的能力,
从而保证redis的访问效率;之后随着硬件的升级,在6.x之后还引入了网络IO多线程,将最耗时的socket数据读取、请求解析、数据写回等操作交于IO线程执行,并且每一个IO线程又可以管理
多个连接,从而更有效地处理大量的并发连接,提高了redis数据访问的效率;保证了即使在更大的并发量时,redis也可以保持很好的效率;
  但需要注意,在redis6/7中,默认情况多线程机制是关闭的,因为对于80%的公司来说,单线程的redis已经足够使用了;
















