# select模式

  # select函数入参结构
  int select(
    int nfds,                   // 要监听的fd_set里最大的fd + 1,该值的目的是告诉系统在遍历我们的fd集合时,数值达到nfds,表示已经进行一次完整的遍历了
    fd_set *readfds,            // 要监听读事件的fd集合
    fd_set *writefds,           // 要监听写事件的fd集合
    fd_set *exceptfds,          // 要监听异常事件的fd集合
    struct timeval *timeout     // 超时时间(即等待fd就绪的时间),取值有三种情况: null-永不超时; 0-不阻塞等待; 大于0-固定等待时间
  );
  typedef struct {
    __fd_mask fds_bits[32];  
} fd_set       // fd_set是一个 __fd_mask 类型的长度为32的数组,而这个__fd_mask 是一个long int类型,在C语言中该类型占据4个字节即32个bit位,所以对于这个fd_set数组来说,他可以存32*32即1024个bit位;
               // 之所以要强调可以存储的bit位数量,是因为我们的fd_set在保存fd时,是一个bit位对应一个fd,而对应bit位为0表示该fd未就绪,bit位为1表示该fd已就绪;
  
  # select函数执行流程:
  - 1.1[用户空间操作] 创建一个监听读事件集合: fd_set,此时我们的fd_set被初始化,即1024个bit位对应的数值都是0;
  - 1.2[用户空间操作]
    假设我们当前要监听的fd值为1,2,5;
    则对应的bit位结果: 0 0 0 1 0 0 1 1
  - 1.3[用户空间操作] 调用select函数, select(5+1, fd_set, null, null, 3) 
    解释一下当前调用时传入参数的含义,
    第一个参数表示:我们要监听的fd_set中最大的fd+1,最大的fd不就是1,2,5中的5吗,所以入参: 5+1
    第二个参数表示:我们要监听的读事件集合,恰好是我们的fd_set
    第三个参数和第四个参数: 因为我们暂时不去监听写事件和异常事件,所以传参均为null
    第五个参数: 大于0,表示我们会等待该select函数3秒钟
  - 2.1[内核空间操作] [注意！,在用户空间中执行select函数的那一刻,就会将用户空间中的fd_set拷贝到内核空间,即此时发生了一次数据在用户态和内核态的切换]
    在内核态中遍历fd_set,由最低位开始遍历,直到我们的数值等于我们传入的参数,nfds为止;
    如果1,2,5三个fd都没有就绪,那么此时会进入等待,在等待时实际上就是内核空间内对fd_set不断进行遍历即轮询
    只要1,2,5中有任意一个fd可读,就会通知我们内核;
  - 2.2[内核空间操作]假如现在fd=1数据就绪,再次遍历fd_set,遍历过程中找到所有被标记为1的fd,即在1,2,5中看他们是否数据就绪,可惜当前只有fd=1就绪,即fd_set现在是: 0 0 0 0 0 0 0 1
    若此时fd=1和fd=5均就绪,则fd_set是: 0 0 0 1 0 0 0 1;
    当我们发现有数据就绪,并完成遍历后,会将当前就绪的fd的个数作为select函数的结果返回给用户空间,并将内核态中的fd_set拷贝至用户空间,并覆盖用户空间中的fd_set,即此时发生了第二次数据在内核态和用户态之间的切换
  - 1.4[用户空间操作] 用户空间获得select结果,当前select结果为1,说明在1024个bit位中有一个fd就绪了
    并且此时的fd_set已经被内核态的结果给覆盖
    ok,那么现在我们知道了我们有几个fd就绪,也由了标记就绪bit位的fd_set,但是我们是不知道具体哪个bit位上的fd就绪,所以我们要自己在用户空间中在遍历一次,找到就绪的fd,读取其中的数据

    至此,一次完整的select函数执行流程结束,那么下一次就可以直接从1.2开始,根据建立socket连接生成的fd值,对我们的fd_set的bit位进行设置,在继续后续的流程;
  
  # select模式存在的问题
  - 在一次select函数的调用中,要经历两次数据在内核态和用户态之间的切换,一次是开始时将待监听的fd_set从用户态拷贝仅内核态,一次是结束时将就绪的fd_set从内核态拷贝回用户态进行覆盖
  - select函数结束时,我们拥有包含就绪的fd的fd_set,但我们不知道具体哪个fd是就绪的,我们需要再用户空间中在进行一次遍历来找到就绪的fd
  - fd_set本身空间只能监控1024个bit位的数据,这就意味着监听的fd数量也不能超过1024,1024这个数量级对于现在的生产开发是远远不够的;
  