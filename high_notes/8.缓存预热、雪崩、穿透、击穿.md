# 缓存预热(了解即可,不重要)
  - 缓存预热理解:
  mysql假如新增100条记录,一般默认以mysql为准作为底单数据,如何同步给redis(布隆过滤器),这100条合法数据？
  之所以需要同步,是为了避免用户在查询时出现较长时间(较长链路)的问题,那此时如果我们能提前将数据同步到redis(布隆过滤器),那么在后续客户使用的过程中,体验感就会好很多;
  简单说缓存预热,就是提前把部分数据通过人为或中间件的方式加入缓存中,来提升使用体验;
  
  - 缓存预热的典型场景
    初始化白名单

# 缓存穿透
  缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在,这样缓存永远不会生效,这些请求都会打到数据库;如果有人恶意利用缓存穿透就可以大量数据直接打到数据库,数据库垮掉
  常见的两种缓存穿透的解决方案：
  - 缓存空对象：
    即数据库会将一个对象的null值缓存到redis,来保证下一次再有这种请求,redis可以处理,并且可以通过设置一个较短的过期时间来让这种无意义数据一段时间内消亡;优点就是代码实现简单,
  维护简单;缺点就是额外的内存消耗,因为还是要向redis中存入一定量垃圾消息;而且会存在短期内存不一致问题;虽然用较短的过期时间可以减少不一致问题发生概率,但总还是可能出现,一个对象,
  redis数据库都没有,然后redis缓存了一个null,但马上我们写入数据库一条关于这个对象的数据,这时数据库有值而redis为null,短期数据不一致就发生了;当然,这种可能性还是比较低的,而且
  过期时间也在减少这种现象的发生,如果实在想杜绝,就只能在数据库更新后手动覆盖redis;
  - 布隆过滤器
    就是在客户端和redis之间增加一个布隆过滤器,如果对象不存在,布隆过滤器会直接拒绝,如果存在,处理流程与正常无异
  
  当然了,无论是redis存null还是布隆过滤器都是在缓存穿透后我们的弥补手段,那我们其实也应该在避免缓存穿透上下一些功夫
  - 增加id复杂度，避免被猜到id规律
  - 做数据的基础格式校验，我们可以标准化数据格式，对于不符合格式的数据直接拒绝
  - 可以针对用户权限进行限流，也可以根据热点参数(比如被频繁点击查阅的商品)进行限流

# 缓存击穿
  缓存击穿问题也叫热点Key问题,就是一个被高并发访问并且缓存重建业务较复杂的Key突然失效了,无效的请求访问会瞬间给数据库带来巨大的冲击;
  常见的两种方案就是互斥锁(分布式锁)和逻辑过期;
  
# 缓存雪崩
  缓存雪崩是指在同一时段,大量的缓存key同时失效或者Redis服务宕机,导致大量请求到达数据库,带来巨大压力
  解决方案：
  - 逻辑过期
  - 给不同的key的TTL添加随机值(避免同一时间大量key同时失效的概率)
  - 利用Redis集群提高服务的可用性
  - 给缓存业务添加降级限流策略(牺牲部分业务，直接将部分业务请求拒绝，来保障数据库不崩)
  - 给业务添加多级缓存
    方案1可以代码实现，方案2需要利用集群，方案3和方案4都是微服务的知识